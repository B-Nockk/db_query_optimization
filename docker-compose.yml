# docker-compose.yml
services:
  api:
    container_name: dbo
    build: .
    image: dbo:dev
    command: uvicorn main:app --host 0.0.0.0 --port 8000 --reload
    volumes:
      - .:/app # bind mount
    # ports:
    # - "${APP_PORT:-8000}:8000" # ‚Üê simple & explicit is usually better for dev
    env_file:
      - .env
    environment:
      - PYTHONUNBUFFERED=1
    healthcheck:
      test: ["CMD", "python", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8000/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    networks:
      - app_network
    restart: unless-stopped # optional but convenient

  nginx:
    container_name: ${COMPOSE_PROJECT_NAME:-dbo}_nginx
    build:
      context: ./nginx
      dockerfile: Dockerfile
    image: ${COMPOSE_PROJECT_NAME:-dbo}_nginx:${IMAGE_TAG:-dev}
    ports:
      - "${NGINX_HTTP_PORT:-80}:80"
      - "${NGINX_HTTPS_PORT:-443}:443"
    environment:
      - API_HOST=api
      - API_PORT=8000
      - SERVER_NAME=${SERVER_NAME:-localhost}
      - SSL_ENABLED=${SSL_ENABLED:-false}
      - SSL_CERT_PATH=/etc/nginx/ssl/cert.pem
      - SSL_KEY_PATH=/etc/nginx/ssl/key.pem
    volumes:
      # Mount SSL certificates (create ssl/ directory first)
      - ${SSL_CERT_DIR:-./ssl}:/etc/nginx/ssl:ro
      # Optional: custom nginx.conf overrides
      # - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      api:
        condition: service_healthy
    networks:
      - app_network
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: "0.5"
          memory: 256M

networks:
  app_network:
    driver: bridge
    name: ${COMPOSE_PROJECT_NAME:-dbo}_network
